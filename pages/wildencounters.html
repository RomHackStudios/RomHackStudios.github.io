<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #27262b;
      color: #ffffff;
    }
    h1 {
      text-align: center;
    }
    label {
      font-weight: bold;
    }
    input[type="text"] {
      margin-bottom: 20px;
      width: 100%;
      padding: 5px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: fixed;
      border: 1px solid #ffffff;
      margin-bottom: 20px;
    }
    th, td {
      text-align: left;
      padding: 10px;
    }
    th {
      background-color: #27262b;
      color: #ffffff;
    }
    td {
      background-color: #1d1c20;
      color: #ffffff;
      border-bottom: 1px solid #ffffff;
    }
    .pokemon-image {
      width: 40px;
      height: 40px;
      vertical-align: middle;
      border-radius: 50%;
    }
    
    @media only screen and (max-width: 600px) {
      table {
        font-size: 14px;
      }
      td, th {
        padding: 5px;
      }
      .pokemon-image {
        width: 30px;
        height: 30px;
      }
    }
  </style>
</head>
<body>
  <div>
    <label for="searchInput">Search:</label>
    <input type="text" id="searchInput" oninput="debounce(searchEncounters, 300)" />
  </div>

  <div id="encounterData"></div>

  <script>
    let allEncountersData = {};

    async function fetchData() {
      try {
        const response = await fetch('wild_encounter_data.json');
        const data = await response.json();
        allEncountersData = data.wild_encounter_groups;
        renderEncounterData();
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    }

   async function fetchPokemonSprite(speciesName) {
  try {
    const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${speciesName.toLowerCase()}`);
    const data = await response.json();
    return data.sprites.front_default;
  } catch (error) {
    console.error('Error fetching Pokemon sprite:', error);
    return null;
  }
}


    function renderEncounterData() {
      const encounterDataDiv = document.getElementById('encounterData');
      encounterDataDiv.innerHTML = '';

      allEncountersData.forEach(group => {
        const encounters = group.encounters;
        encounters.forEach(encounter => {
          const table = document.createElement('table');
          const header = document.createElement('th');
          const mapName = encounter.map.replace('MAP_', '');
          header.textContent = `Encounters for ${mapName}`;
          header.colSpan = 4;
          table.appendChild(header);

          group.fields.forEach(field => {
            const type = field.type;
            const encounterData = encounter[type];
            if (encounterData) {
              const detailsRows = encounterData.mons.map(async (mon, index) => {
                const detailsRow = document.createElement('tr');
                const spriteURL = await fetchPokemonSprite(mon.species.replace('SPECIES_', ''));
                const imageCell = document.createElement('td');
                if (spriteURL) {
                  const image = document.createElement('img');
                  image.className = 'pokemon-image';
                  image.src = spriteURL;
                  image.alt = mon.species.replace('SPECIES_', '');
                  imageCell.appendChild(image);
                }
                detailsRow.appendChild(imageCell);

                const pokemonCell = document.createElement('td');
                pokemonCell.textContent = mon.species.replace('SPECIES_', '');
                detailsRow.appendChild(pokemonCell);

                const levelsCell = document.createElement('td');
                levelsCell.textContent = `${mon.min_level}-${mon.max_level}`;
                detailsRow.appendChild(levelsCell);

                const rateCell = document.createElement('td');
                rateCell.textContent = `${field.encounter_rates[index]}%`;
                detailsRow.appendChild(rateCell);

                return detailsRow;
              });

              Promise.all(detailsRows).then(rows => {
                rows.forEach(row => {
                  table.appendChild(row);
                });
                encounterDataDiv.appendChild(table);
              });
            }
          });
        });
      });
    }

    function searchEncounters() {
      const searchInput = document.getElementById('searchInput').value.toLowerCase();
      const encounterTables = document.querySelectorAll('#encounterData table');

      encounterTables.forEach(table => {
        const rows = table.getElementsByTagName('tr');
        let hasMatch = false;

        for (let i = 2; i < rows.length; i++) {
          const cells = rows[i].getElementsByTagName('td');
          let matchFound = false;

          for (let j = 1; j < cells.length; j++) {
            const cellText = cells[j].textContent.toLowerCase();

            if (cellText.includes(searchInput)) {
              matchFound = true;
              break;
            }
          }

          if (matchFound) {
            rows[i].style.display = '';
            hasMatch = true;
          } else {
            rows[i].style.display = 'none';
          }
        }

        if (hasMatch) {
          table.style.display = '';
        } else {
          table.style.display = 'none';
        }
      });
    }

    function debounce(func, timeout) {
      let timer;
      return function () {
        const context = this;
        const args = arguments;
        clearTimeout(timer);
        timer = setTimeout(() => {
          func.apply(context, args);
        }, timeout);
      };
    }

    fetchData(); // Fetch data on page load
  </script>
</body>
</html>
