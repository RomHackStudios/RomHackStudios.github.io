<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #27262b;
      color: #ffffff;
    }

    h1 {
      text-align: center;
    }

    label {
      font-weight: bold;
    }

    input[type="text"] {
      margin-bottom: 20px;
      width: 100%;
      padding: 5px;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: fixed;
      border: 1px solid #ffffff;
      margin-bottom: 20px;
    }

    th, td {
      text-align: left;
      padding: 10px;
    }

    th {
      background-color: #27262b;
      color: #ffffff;
    }

    td {
      background-color: #1d1c20;
      color: #ffffff;
      border-bottom: 1px solid #ffffff;
    }

    .pokemon-image {
      width: 40px;
      height: 40px;
      vertical-align: middle;
      border-radius: 50%;
    }
    
    @media only screen and (max-width: 600px) {
      table {
        font-size: 14px;
      }

      td, th {
        padding: 5px;
      }

      .pokemon-image {
        width: 30px;
        height: 30px;
      }
    }
  </style>
</head>
</head>
<body>
  <div>
    <label for="searchInput">Search:</label>
    <input type="text" id="searchInput" />
    <button onclick="searchPokemonEncounters()">Search</button>
  </div>

  <div id="encounterData"></div>

  <script>
    async function fetchPokemonData(url) {
      try {
        const response = await fetch(url);
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Error fetching Pokemon data:', error);
        return null;
      }
    }

    async function fetchPokemonSprite(speciesName) {
      const url = `https://pokeapi.co/api/v2/pokemon-species/${speciesName.toLowerCase()}`;
      const pokemonData = await fetchPokemonData(url);
      if (pokemonData && pokemonData.varieties && pokemonData.varieties.length > 0) {
        const varietyURL = pokemonData.varieties[0].pokemon.url;
        const varietyData = await fetchPokemonData(varietyURL);
        if (varietyData && varietyData.sprites && varietyData.sprites.front_default) {
          return varietyData.sprites.front_default;
        }
      }
      return null;
    }

    function renderEncounterData(data) {
      const encounterDataDiv = document.getElementById('encounterData');
      encounterDataDiv.innerHTML = ''; // Clear previous results

      data.forEach(group => {
        const encounters = group.encounters;

        encounters.forEach(async encounter => {
          const table = document.createElement('table');

          const header = document.createElement('th');
          const mapName = encounter.map.replace('MAP_', '');
          header.textContent = `Encounters for ${mapName}`;
          header.colSpan = 4;
          table.appendChild(header);

          group.fields.forEach(async field => {
            const type = field.type;
            const encounterData = encounter[type];

            if (encounterData) {
              encounterData.mons.forEach(async mon => {
                const speciesName = mon.species.replace('SPECIES_', '');

                if (speciesName.toLowerCase().includes(searchInput)) {
                  const spriteURL = await fetchPokemonSprite(speciesName);

                  const detailsRow = document.createElement('tr');

                  const imageCell = document.createElement('td');
                  if (spriteURL) {
                    const image = document.createElement('img');
                    image.className = 'pokemon-image';
                    image.src = spriteURL;
                    image.alt = speciesName;
                    imageCell.appendChild(image);
                  }
                  detailsRow.appendChild(imageCell);

                  const pokemonCell = document.createElement('td');
                  pokemonCell.textContent = speciesName;
                  detailsRow.appendChild(pokemonCell);

                  const levelsCell = document.createElement('td');
                  levelsCell.textContent = `${mon.min_level}-${mon.max_level}`;
                  detailsRow.appendChild(levelsCell);

                  const rateCell = document.createElement('td');
                  rateCell.textContent = `${field.encounter_rates}%`;
                  detailsRow.appendChild(rateCell);

                  table.appendChild(detailsRow);
                }
              });
            }
          });

          encounterDataDiv.appendChild(table);
        });
      });
    }

    async function searchPokemonEncounters() {
      const searchInput = document.getElementById('searchInput').value.toLowerCase();

      fetch('wild_encounter_data.json')
        .then(response => response.json())
        .then(data => {
          const encounterData = data.wild_encounter_groups;

          const filteredData = encounterData.map(group => {
            const encounters = group.encounters.filter(encounter => {
              const mons = encounter.land.mons.concat(encounter.water.mons);
              return mons.some(mon => mon.species.toLowerCase().includes(searchInput));
            });

            if (encounters.length > 0) {
              return { ...group, encounters };
            }
          }).filter(Boolean);

          renderEncounterData(filteredData);
        });
    }
  </script>
</body>
</html>
